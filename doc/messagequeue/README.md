- [1. 消息队列简介](#title_1)
- [2. 为什么要使用消息队列](#title_2)
- [3. 使用消息队列我们需要关注的一些问题](#title_3)
- [4. 消息队列的两种协议 JMS 、 AMQP](#title_4)
- [5. 常见的消息队列对比](#title_5)



### 前言

为什么要写消息队列？主要和自己目前在公司负责 IM系统和交易系统有关。在其中很多地方聊天消息削峰、对交易链路的异步化，这些都是借助 MQ 的能力，在我们系统中得以完成。

### <p id="title_1">1. 消息队列简介</p>

我们日常生活中使用的快递，实际就是一个消息队列的模型。商家把快递邮寄到快递点，快递点通知我们有快递去签收。可能通知的时候我们正在上班，没有时间去取快递。等到我们下班的时候再去取快递。

![Message queue](/images/messagequeue/message-queue-small.png)

消息队列作为分布式系统中不可缺失的一环，通过将同步改为异步处理的方式，提高了系统性能，将大流量削峰、降低系统耦合性。

通过使用 Queue 这种先进先出的数据结构，保证了消息消费时也是按照顺序消费的。

### <p id="title_2">2. 为什么要使用消息队列?</p>

回答这个问题前，我们要思考下当我们遇到以下情况该如何去做？

1. 网站瞬间 QPS 非常高，这是我们为了解决这种瞬间流量是扩机器解决？还是放任不管等待服务恢复？
2. 在微服务流行的如今，如何保证分布式事务的最终一致性？

当你遇到这种问题时，很多情况下我们首先能想到的选择里，一定都会有消息队列。

通常来说，使用消息队列能为我们的系统带来下面三点好处：

1. **通过异步处理提高系统性能（减少响应所需时间）。**
2. **削峰/限流**
3. **降低系统耦合性。**

#### 2.1 通过异步处理，提高服务响应时间。

用户调用一个接口的时候，可能该接口调用了别的方法。例如：用户注册的时候，后台可能需要调用：查询数据库，插入数据库，发送邮件，发送用户指南等等...

但是用户可能并不需要后台将所有的任务执行完毕，那么此时在初入数据口后面加入mq队列，用户就能很快得到注册成功的响应而去做一些别的事情。mq的机制又能保证最终的一致性，所以使用起来很安全很稳定。

#### 2.2 削峰/限流

拿笔者目前从事的工作来说，一个订单下单的流程设计到：商品、物流、IM、支付等系统。**后端在收到用户交易后，可以先响应用户下单成功这以结果，然后将消息投递到 MQ ，等待系统慢慢消费用户下单这一消息。**

![削峰](/images/messagequeue/削峰-消息队列.png)

#### 2.3 降低系统耦合性

生产者（客户端）发送消息到消息队列中去，接受者（服务端）处理消息，需要消费的系统直接去消息队列取消息进行消费即可而不需要和其他系统有耦合，这显然也提高了系统的扩展性。

### <p id="title_3">3. 使用消息队列我们需要关注的一些问题</p>

系统引入任何框架，它解决了你当时所面临的问题以外，也会带来一些问题。所以我们程序员引入框架时，一定要做好前期调研。

- **系统可用性降低：** 在没有引入 MQ 之前，你可能只需要关注 Java 应用和 数据库 运行稳定就好了。但是当你引入 MQ 之后，你还需要关注 MQ 服务异常消息丢失、 MQ 服务挂起导致整个系统无法工作等情况。
- **系统复杂性提高：** 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
- **一致性问题：** 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!

#### <p id="title_4">4. 消息队列的两种协议 JMS 、 AMQP</p>

###  4.1 JMS

#### 4.1.1 JMS 简介

JMS（JAVA Message Service,java 消息服务）是 java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。**JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范**，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。

**ActiveMQ 就是基于 JMS 规范实现的。**

#### 4.1.2 JMS 两种消息模型

**① 点到点（P2P）模型**

![点到点（P2P）模型](/images/messagequeue/162e7185572ca37d)

使用**队列（Queue）**作为消息通信载体；满足\**生产者与消费者模式**，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。比如：我们生产者发送 100 条消息的话，两个消费者来消费一般情况下两个消费者会按照消息发送的顺序各自消费一半（也就是你一个我一个的消费。）

**② 发布/订阅（Pub/Sub）模型**

![发布/订阅（Pub/Sub）模型](/images/messagequeue/162e7187c268eaa5)

发布订阅模型（Pub/Sub） 使用**主题（Topic）**作为消息通信载体，类似于\**广播模式**；发布者发布一条消息，该消息通过主题传递给所有的订阅者，**在一条消息广播之后才订阅的用户则是收不到该条消息的**。

#### 4.1.3 JMS 五种不同的消息正文格式

JMS 定义了五种不同的消息正文格式，以及调用的消息类型，允许你发送并接收以一些不同形式的数据，提供现有消息格式的一些级别的兼容性。

- StreamMessage -- Java 原始值的数据流
- MapMessage--一套名称-值对
- TextMessage--一个字符串对象
- ObjectMessage--一个序列化的 Java 对象
- BytesMessage--一个字节的数据流

### 4.2 AMQP

AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 **高级消息队列协议**（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。

**RabbitMQ 就是基于 AMQP 协议实现的。**

### 4.3 JMS vs AMQP

| 对比方向     | JMS                                     | AMQP                                                         |
| ------------ | --------------------------------------- | ------------------------------------------------------------ |
| 定义         | Java API                                | 协议                                                         |
| 跨语言       | 否                                      | 是                                                           |
| 跨平台       | 否                                      | 是                                                           |
| 支持消息类型 | 提供两种消息模型：①Peer-2-Peer;②Pub/sub | 提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub/sub 模型没有太大差别，仅是在路由机制上做了更详细的划分； |
| 支持消息类型 | 支持多种消息类型 ，我们在上面提到过     | byte[]（二进制）                                             |

**总结：**

- AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。
- JMS 支持 TextMessage、MapMessage 等复杂的消息类型；而 AMQP 仅支持 byte[] 消息类型（复杂的类型可序列化后发送）。
- 由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。

### <p id="title_5">5. 常见的消息队列对比</p>

|          | activeMQ     | rabbitMQ | RocketMQ | Kafka                        |
| -------- | ------------ | -------- | -------- | ---------------------------- |
| 并发量   | 万级         | 万级     | 十万级   | 万级                         |
| 响应时长 | 毫秒         | 微秒     | 毫秒     | 毫秒                         |
| 开发语言 | Java         | Erlang   | Java     | Java Scale                   |
| 功能完备 | 完备         | 完备     | 完备     | 不完备                       |
| 常用场景 | 小型项目demo | *        | *        | 大数据领域日志处理、实时计算 |
| 社区     | 低           | 高       | 一般     | 高                           |

**总结：**

- RabbitMQ 在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做 erlang 源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。
- RocketMQ 阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的 MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。
- Kafka 的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。
